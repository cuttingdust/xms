// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: XMsgCom.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_XMsgCom_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_XMsgCom_2eproto_2epb_2eh

#include "XPlatfrom_Global.h"

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h" // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "XMsgType.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_XMsgCom_2eproto

namespace google
{
    namespace protobuf
    {
        namespace internal
        {
            class AnyMetadata;
        } // namespace internal
    }     // namespace protobuf
} // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_XMsgCom_2eproto
{
    static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_XMsgCom_2eproto;
namespace xmsg
{
    class XDirReq;
    struct XDirReqDefaultTypeInternal;
    extern XDirReqDefaultTypeInternal _XDirReq_default_instance_;
    class XDirRes;
    struct XDirResDefaultTypeInternal;
    extern XDirResDefaultTypeInternal _XDirRes_default_instance_;
    class XDirRes_XDir;
    struct XDirRes_XDirDefaultTypeInternal;
    extern XDirRes_XDirDefaultTypeInternal _XDirRes_XDir_default_instance_;
    class XLoginReq;
    struct XLoginReqDefaultTypeInternal;
    extern XLoginReqDefaultTypeInternal _XLoginReq_default_instance_;
    class XLoginRes;
    struct XLoginResDefaultTypeInternal;
    extern XLoginResDefaultTypeInternal _XLoginRes_default_instance_;
    class XMsgHead;
    struct XMsgHeadDefaultTypeInternal;
    extern XMsgHeadDefaultTypeInternal _XMsgHead_default_instance_;
} // namespace xmsg
namespace google
{
    namespace protobuf
    {
    } // namespace protobuf
} // namespace google

namespace xmsg
{
    enum XLoginRes_XLoginResType : int
    {
        XLoginRes_XLoginResType_XRT_OK      = 0,
        XLoginRes_XLoginResType_XRT_ERR     = 1,
        XLoginRes_XLoginResType_XRT_NO_USER = 2,
        XLoginRes_XLoginResType_XLoginRes_XLoginResType_INT_MIN_SENTINEL_DO_NOT_USE_ =
                std::numeric_limits<::int32_t>::min(),
        XLoginRes_XLoginResType_XLoginRes_XLoginResType_INT_MAX_SENTINEL_DO_NOT_USE_ =
                std::numeric_limits<::int32_t>::max(),
    };

    bool                              XLoginRes_XLoginResType_IsValid(int value);
    extern const uint32_t             XLoginRes_XLoginResType_internal_data_[];
    constexpr XLoginRes_XLoginResType XLoginRes_XLoginResType_XLoginResType_MIN =
            static_cast<XLoginRes_XLoginResType>(0);
    constexpr XLoginRes_XLoginResType XLoginRes_XLoginResType_XLoginResType_MAX =
            static_cast<XLoginRes_XLoginResType>(2);
    constexpr int                             XLoginRes_XLoginResType_XLoginResType_ARRAYSIZE = 2 + 1;
    const ::google::protobuf::EnumDescriptor* XLoginRes_XLoginResType_descriptor();
    template <typename T>
    const std::string& XLoginRes_XLoginResType_Name(T value)
    {
        static_assert(std::is_same<T, XLoginRes_XLoginResType>::value || std::is_integral<T>::value,
                      "Incorrect type passed to XLoginResType_Name().");
        return XLoginRes_XLoginResType_Name(static_cast<XLoginRes_XLoginResType>(value));
    }
    template <>
    inline const std::string& XLoginRes_XLoginResType_Name(XLoginRes_XLoginResType value)
    {
        return ::google::protobuf::internal::NameOfDenseEnum<XLoginRes_XLoginResType_descriptor, 0, 2>(
                static_cast<int>(value));
    }
    inline bool XLoginRes_XLoginResType_Parse(absl::string_view name, XLoginRes_XLoginResType* value)
    {
        return ::google::protobuf::internal::ParseNamedEnum<XLoginRes_XLoginResType>(
                XLoginRes_XLoginResType_descriptor(), name, value);
    }
    enum XDirRes_XDirType : int
    {
        XDirRes_XDirType_XDT_OK                                        = 0,
        XDirRes_XDirType_XDT_ERROR                                     = 1,
        XDirRes_XDirType_XDT_NODIR                                     = 2,
        XDirRes_XDirType_XDirRes_XDirType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::min(),
        XDirRes_XDirType_XDirRes_XDirType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::int32_t>::max(),
    };

    bool                                      XDirRes_XDirType_IsValid(int value);
    extern const uint32_t                     XDirRes_XDirType_internal_data_[];
    constexpr XDirRes_XDirType                XDirRes_XDirType_XDirType_MIN       = static_cast<XDirRes_XDirType>(0);
    constexpr XDirRes_XDirType                XDirRes_XDirType_XDirType_MAX       = static_cast<XDirRes_XDirType>(2);
    constexpr int                             XDirRes_XDirType_XDirType_ARRAYSIZE = 2 + 1;
    const ::google::protobuf::EnumDescriptor* XDirRes_XDirType_descriptor();
    template <typename T>
    const std::string& XDirRes_XDirType_Name(T value)
    {
        static_assert(std::is_same<T, XDirRes_XDirType>::value || std::is_integral<T>::value,
                      "Incorrect type passed to XDirType_Name().");
        return XDirRes_XDirType_Name(static_cast<XDirRes_XDirType>(value));
    }
    template <>
    inline const std::string& XDirRes_XDirType_Name(XDirRes_XDirType value)
    {
        return ::google::protobuf::internal::NameOfDenseEnum<XDirRes_XDirType_descriptor, 0, 2>(
                static_cast<int>(value));
    }
    inline bool XDirRes_XDirType_Parse(absl::string_view name, XDirRes_XDirType* value)
    {
        return ::google::protobuf::internal::ParseNamedEnum<XDirRes_XDirType>(XDirRes_XDirType_descriptor(), name,
                                                                              value);
    }

    // ===================================================================


    // -------------------------------------------------------------------

    class XPLATFROM_EXPORT XMsgHead final
        : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xmsg.XMsgHead) */
    {
    public:
        inline XMsgHead() : XMsgHead(nullptr)
        {
        }
        ~XMsgHead() override;
        template <typename = void>
        explicit PROTOBUF_CONSTEXPR XMsgHead(::google::protobuf::internal::ConstantInitialized);

        inline XMsgHead(const XMsgHead& from) : XMsgHead(nullptr, from)
        {
        }
        XMsgHead(XMsgHead&& from) noexcept : XMsgHead()
        {
            *this = ::std::move(from);
        }

        inline XMsgHead& operator=(const XMsgHead& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline XMsgHead& operator=(XMsgHead&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(
                    ::google::protobuf::UnknownFieldSet::default_instance);
        }
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
        }

        static const ::google::protobuf::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::google::protobuf::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::google::protobuf::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const XMsgHead& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const XMsgHead* internal_default_instance()
        {
            return reinterpret_cast<const XMsgHead*>(&_XMsgHead_default_instance_);
        }
        static constexpr int kIndexInFileMessages = 0;

        friend void swap(XMsgHead& a, XMsgHead& b)
        {
            a.Swap(&b);
        }
        inline void Swap(XMsgHead* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() != nullptr && GetArena() == other->GetArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() == other->GetArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::google::protobuf::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(XMsgHead* other)
        {
            if (other == this)
                return;
            ABSL_DCHECK(GetArena() == other->GetArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        XMsgHead* New(::google::protobuf::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<XMsgHead>(arena);
        }
        using ::google::protobuf::Message::CopyFrom;
        void CopyFrom(const XMsgHead& from);
        using ::google::protobuf::Message::MergeFrom;
        void MergeFrom(const XMsgHead& from)
        {
            XMsgHead::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool                                  IsInitialized() const final;

        ::size_t    ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
        ::uint8_t*  _InternalSerialize(::uint8_t*                                   target,
                                       ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
        int         GetCachedSize() const
        {
            return _impl_._cached_size_.Get();
        }

    private:
        ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
        void                                      SharedCtor(::google::protobuf::Arena* arena);
        void                                      SharedDtor();
        void                                      InternalSwap(XMsgHead* other);

    private:
        friend class ::google::protobuf::internal::AnyMetadata;
        static ::absl::string_view FullMessageName()
        {
            return "xmsg.XMsgHead";
        }

    protected:
        explicit XMsgHead(::google::protobuf::Arena* arena);
        XMsgHead(::google::protobuf::Arena* arena, const XMsgHead& from);

    public:
        static const ClassData                        _class_data_;
        const ::google::protobuf::Message::ClassData* GetClassData() const final;

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kTokenFieldNumber      = 3,
            kServerNameFieldNumber = 4,
            kMsgSizeFieldNumber    = 1,
            kMsgTypeFieldNumber    = 2,
        };
        // string token = 3;
        void               clear_token();
        const std::string& token() const;
        template <typename Arg_ = const std::string&, typename... Args_>
        void               set_token(Arg_&& arg, Args_... args);
        std::string*       mutable_token();
        PROTOBUF_NODISCARD std::string* release_token();
        void                            set_allocated_token(std::string* value);

    private:
        const std::string&                 _internal_token() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
        std::string*                       _internal_mutable_token();

    public:
        // string serverName = 4;
        void               clear_servername();
        const std::string& servername() const;
        template <typename Arg_ = const std::string&, typename... Args_>
        void               set_servername(Arg_&& arg, Args_... args);
        std::string*       mutable_servername();
        PROTOBUF_NODISCARD std::string* release_servername();
        void                            set_allocated_servername(std::string* value);

    private:
        const std::string&                 _internal_servername() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_servername(const std::string& value);
        std::string*                       _internal_mutable_servername();

    public:
        // int32 msgSize = 1;
        void      clear_msgsize();
        ::int32_t msgsize() const;
        void      set_msgsize(::int32_t value);

    private:
        ::int32_t _internal_msgsize() const;
        void      _internal_set_msgsize(::int32_t value);

    public:
        // .xmsg.MsgType msgType = 2;
        void            clear_msgtype();
        ::xmsg::MsgType msgtype() const;
        void            set_msgtype(::xmsg::MsgType value);

    private:
        ::xmsg::MsgType _internal_msgtype() const;
        void            _internal_set_msgtype(::xmsg::MsgType value);

    public:
        // @@protoc_insertion_point(class_scope:xmsg.XMsgHead)
    private:
        class _Internal;

        friend class ::google::protobuf::internal::TcParser;
        static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 37, 2> _table_;
        friend class ::google::protobuf::MessageLite;
        friend class ::google::protobuf::Arena;
        template <typename T>
        friend class ::google::protobuf::Arena::InternalHelper;
        using InternalArenaConstructable_ = void;
        using DestructorSkippable_        = void;
        struct Impl_
        {
            inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena*                       arena);
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena* arena, const Impl_& from);
            ::google::protobuf::internal::ArenaStringPtr     token_;
            ::google::protobuf::internal::ArenaStringPtr     servername_;
            ::int32_t                                        msgsize_;
            int                                              msgtype_;
            mutable ::google::protobuf::internal::CachedSize _cached_size_;
            PROTOBUF_TSAN_DECLARE_MEMBER
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_XMsgCom_2eproto;
    }; // -------------------------------------------------------------------

    class XLoginRes final
        : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xmsg.XLoginRes) */
    {
    public:
        inline XLoginRes() : XLoginRes(nullptr)
        {
        }
        ~XLoginRes() override;
        template <typename = void>
        explicit PROTOBUF_CONSTEXPR XLoginRes(::google::protobuf::internal::ConstantInitialized);

        inline XLoginRes(const XLoginRes& from) : XLoginRes(nullptr, from)
        {
        }
        XLoginRes(XLoginRes&& from) noexcept : XLoginRes()
        {
            *this = ::std::move(from);
        }

        inline XLoginRes& operator=(const XLoginRes& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline XLoginRes& operator=(XLoginRes&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(
                    ::google::protobuf::UnknownFieldSet::default_instance);
        }
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
        }

        static const ::google::protobuf::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::google::protobuf::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::google::protobuf::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const XLoginRes& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const XLoginRes* internal_default_instance()
        {
            return reinterpret_cast<const XLoginRes*>(&_XLoginRes_default_instance_);
        }
        static constexpr int kIndexInFileMessages = 2;

        friend void swap(XLoginRes& a, XLoginRes& b)
        {
            a.Swap(&b);
        }
        inline void Swap(XLoginRes* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() != nullptr && GetArena() == other->GetArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() == other->GetArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::google::protobuf::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(XLoginRes* other)
        {
            if (other == this)
                return;
            ABSL_DCHECK(GetArena() == other->GetArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        XLoginRes* New(::google::protobuf::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<XLoginRes>(arena);
        }
        using ::google::protobuf::Message::CopyFrom;
        void CopyFrom(const XLoginRes& from);
        using ::google::protobuf::Message::MergeFrom;
        void MergeFrom(const XLoginRes& from)
        {
            XLoginRes::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool                                  IsInitialized() const final;

        ::size_t    ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
        ::uint8_t*  _InternalSerialize(::uint8_t*                                   target,
                                       ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
        int         GetCachedSize() const
        {
            return _impl_._cached_size_.Get();
        }

    private:
        ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
        void                                      SharedCtor(::google::protobuf::Arena* arena);
        void                                      SharedDtor();
        void                                      InternalSwap(XLoginRes* other);

    private:
        friend class ::google::protobuf::internal::AnyMetadata;
        static ::absl::string_view FullMessageName()
        {
            return "xmsg.XLoginRes";
        }

    protected:
        explicit XLoginRes(::google::protobuf::Arena* arena);
        XLoginRes(::google::protobuf::Arena* arena, const XLoginRes& from);

    public:
        static const ClassData                        _class_data_;
        const ::google::protobuf::Message::ClassData* GetClassData() const final;

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        using XLoginResType                        = XLoginRes_XLoginResType;
        static constexpr XLoginResType XRT_OK      = XLoginRes_XLoginResType_XRT_OK;
        static constexpr XLoginResType XRT_ERR     = XLoginRes_XLoginResType_XRT_ERR;
        static constexpr XLoginResType XRT_NO_USER = XLoginRes_XLoginResType_XRT_NO_USER;
        static inline bool             XLoginResType_IsValid(int value)
        {
            return XLoginRes_XLoginResType_IsValid(value);
        }
        static constexpr XLoginResType XLoginResType_MIN       = XLoginRes_XLoginResType_XLoginResType_MIN;
        static constexpr XLoginResType XLoginResType_MAX       = XLoginRes_XLoginResType_XLoginResType_MAX;
        static constexpr int           XLoginResType_ARRAYSIZE = XLoginRes_XLoginResType_XLoginResType_ARRAYSIZE;
        static inline const ::google::protobuf::EnumDescriptor* XLoginResType_descriptor()
        {
            return XLoginRes_XLoginResType_descriptor();
        }
        template <typename T>
        static inline const std::string& XLoginResType_Name(T value)
        {
            return XLoginRes_XLoginResType_Name(value);
        }
        static inline bool XLoginResType_Parse(absl::string_view name, XLoginResType* value)
        {
            return XLoginRes_XLoginResType_Parse(name, value);
        }

        // accessors -------------------------------------------------------

        enum : int
        {
            kTokenFieldNumber   = 2,
            kResTypeFieldNumber = 1,
        };
        // string token = 2;
        void               clear_token();
        const std::string& token() const;
        template <typename Arg_ = const std::string&, typename... Args_>
        void               set_token(Arg_&& arg, Args_... args);
        std::string*       mutable_token();
        PROTOBUF_NODISCARD std::string* release_token();
        void                            set_allocated_token(std::string* value);

    private:
        const std::string&                 _internal_token() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
        std::string*                       _internal_mutable_token();

    public:
        // .xmsg.XLoginRes.XLoginResType resType = 1;
        void                            clear_restype();
        ::xmsg::XLoginRes_XLoginResType restype() const;
        void                            set_restype(::xmsg::XLoginRes_XLoginResType value);

    private:
        ::xmsg::XLoginRes_XLoginResType _internal_restype() const;
        void                            _internal_set_restype(::xmsg::XLoginRes_XLoginResType value);

    public:
        // @@protoc_insertion_point(class_scope:xmsg.XLoginRes)
    private:
        class _Internal;

        friend class ::google::protobuf::internal::TcParser;
        static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 28, 2> _table_;
        friend class ::google::protobuf::MessageLite;
        friend class ::google::protobuf::Arena;
        template <typename T>
        friend class ::google::protobuf::Arena::InternalHelper;
        using InternalArenaConstructable_ = void;
        using DestructorSkippable_        = void;
        struct Impl_
        {
            inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena*                       arena);
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena* arena, const Impl_& from);
            ::google::protobuf::internal::ArenaStringPtr     token_;
            int                                              restype_;
            mutable ::google::protobuf::internal::CachedSize _cached_size_;
            PROTOBUF_TSAN_DECLARE_MEMBER
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_XMsgCom_2eproto;
    }; // -------------------------------------------------------------------

    class XLoginReq final
        : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xmsg.XLoginReq) */
    {
    public:
        inline XLoginReq() : XLoginReq(nullptr)
        {
        }
        ~XLoginReq() override;
        template <typename = void>
        explicit PROTOBUF_CONSTEXPR XLoginReq(::google::protobuf::internal::ConstantInitialized);

        inline XLoginReq(const XLoginReq& from) : XLoginReq(nullptr, from)
        {
        }
        XLoginReq(XLoginReq&& from) noexcept : XLoginReq()
        {
            *this = ::std::move(from);
        }

        inline XLoginReq& operator=(const XLoginReq& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline XLoginReq& operator=(XLoginReq&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(
                    ::google::protobuf::UnknownFieldSet::default_instance);
        }
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
        }

        static const ::google::protobuf::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::google::protobuf::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::google::protobuf::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const XLoginReq& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const XLoginReq* internal_default_instance()
        {
            return reinterpret_cast<const XLoginReq*>(&_XLoginReq_default_instance_);
        }
        static constexpr int kIndexInFileMessages = 1;

        friend void swap(XLoginReq& a, XLoginReq& b)
        {
            a.Swap(&b);
        }
        inline void Swap(XLoginReq* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() != nullptr && GetArena() == other->GetArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() == other->GetArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::google::protobuf::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(XLoginReq* other)
        {
            if (other == this)
                return;
            ABSL_DCHECK(GetArena() == other->GetArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        XLoginReq* New(::google::protobuf::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<XLoginReq>(arena);
        }
        using ::google::protobuf::Message::CopyFrom;
        void CopyFrom(const XLoginReq& from);
        using ::google::protobuf::Message::MergeFrom;
        void MergeFrom(const XLoginReq& from)
        {
            XLoginReq::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool                                  IsInitialized() const final;

        ::size_t    ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
        ::uint8_t*  _InternalSerialize(::uint8_t*                                   target,
                                       ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
        int         GetCachedSize() const
        {
            return _impl_._cached_size_.Get();
        }

    private:
        ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
        void                                      SharedCtor(::google::protobuf::Arena* arena);
        void                                      SharedDtor();
        void                                      InternalSwap(XLoginReq* other);

    private:
        friend class ::google::protobuf::internal::AnyMetadata;
        static ::absl::string_view FullMessageName()
        {
            return "xmsg.XLoginReq";
        }

    protected:
        explicit XLoginReq(::google::protobuf::Arena* arena);
        XLoginReq(::google::protobuf::Arena* arena, const XLoginReq& from);

    public:
        static const ClassData                        _class_data_;
        const ::google::protobuf::Message::ClassData* GetClassData() const final;

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kUsernameFieldNumber = 1,
            kPasswordFieldNumber = 2,
        };
        // string username = 1;
        void               clear_username();
        const std::string& username() const;
        template <typename Arg_ = const std::string&, typename... Args_>
        void               set_username(Arg_&& arg, Args_... args);
        std::string*       mutable_username();
        PROTOBUF_NODISCARD std::string* release_username();
        void                            set_allocated_username(std::string* value);

    private:
        const std::string&                 _internal_username() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
        std::string*                       _internal_mutable_username();

    public:
        // string password = 2;
        void               clear_password();
        const std::string& password() const;
        template <typename Arg_ = const std::string&, typename... Args_>
        void               set_password(Arg_&& arg, Args_... args);
        std::string*       mutable_password();
        PROTOBUF_NODISCARD std::string* release_password();
        void                            set_allocated_password(std::string* value);

    private:
        const std::string&                 _internal_password() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
        std::string*                       _internal_mutable_password();

    public:
        // @@protoc_insertion_point(class_scope:xmsg.XLoginReq)
    private:
        class _Internal;

        friend class ::google::protobuf::internal::TcParser;
        static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 39, 2> _table_;
        friend class ::google::protobuf::MessageLite;
        friend class ::google::protobuf::Arena;
        template <typename T>
        friend class ::google::protobuf::Arena::InternalHelper;
        using InternalArenaConstructable_ = void;
        using DestructorSkippable_        = void;
        struct Impl_
        {
            inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena*                       arena);
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena* arena, const Impl_& from);
            ::google::protobuf::internal::ArenaStringPtr     username_;
            ::google::protobuf::internal::ArenaStringPtr     password_;
            mutable ::google::protobuf::internal::CachedSize _cached_size_;
            PROTOBUF_TSAN_DECLARE_MEMBER
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_XMsgCom_2eproto;
    }; // -------------------------------------------------------------------

    class XDirRes_XDir final
        : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xmsg.XDirRes.XDir) */
    {
    public:
        inline XDirRes_XDir() : XDirRes_XDir(nullptr)
        {
        }
        ~XDirRes_XDir() override;
        template <typename = void>
        explicit PROTOBUF_CONSTEXPR XDirRes_XDir(::google::protobuf::internal::ConstantInitialized);

        inline XDirRes_XDir(const XDirRes_XDir& from) : XDirRes_XDir(nullptr, from)
        {
        }
        XDirRes_XDir(XDirRes_XDir&& from) noexcept : XDirRes_XDir()
        {
            *this = ::std::move(from);
        }

        inline XDirRes_XDir& operator=(const XDirRes_XDir& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline XDirRes_XDir& operator=(XDirRes_XDir&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(
                    ::google::protobuf::UnknownFieldSet::default_instance);
        }
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
        }

        static const ::google::protobuf::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::google::protobuf::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::google::protobuf::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const XDirRes_XDir& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const XDirRes_XDir* internal_default_instance()
        {
            return reinterpret_cast<const XDirRes_XDir*>(&_XDirRes_XDir_default_instance_);
        }
        static constexpr int kIndexInFileMessages = 4;

        friend void swap(XDirRes_XDir& a, XDirRes_XDir& b)
        {
            a.Swap(&b);
        }
        inline void Swap(XDirRes_XDir* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() != nullptr && GetArena() == other->GetArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() == other->GetArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::google::protobuf::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(XDirRes_XDir* other)
        {
            if (other == this)
                return;
            ABSL_DCHECK(GetArena() == other->GetArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        XDirRes_XDir* New(::google::protobuf::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<XDirRes_XDir>(arena);
        }
        using ::google::protobuf::Message::CopyFrom;
        void CopyFrom(const XDirRes_XDir& from);
        using ::google::protobuf::Message::MergeFrom;
        void MergeFrom(const XDirRes_XDir& from)
        {
            XDirRes_XDir::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool                                  IsInitialized() const final;

        ::size_t    ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
        ::uint8_t*  _InternalSerialize(::uint8_t*                                   target,
                                       ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
        int         GetCachedSize() const
        {
            return _impl_._cached_size_.Get();
        }

    private:
        ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
        void                                      SharedCtor(::google::protobuf::Arena* arena);
        void                                      SharedDtor();
        void                                      InternalSwap(XDirRes_XDir* other);

    private:
        friend class ::google::protobuf::internal::AnyMetadata;
        static ::absl::string_view FullMessageName()
        {
            return "xmsg.XDirRes.XDir";
        }

    protected:
        explicit XDirRes_XDir(::google::protobuf::Arena* arena);
        XDirRes_XDir(::google::protobuf::Arena* arena, const XDirRes_XDir& from);

    public:
        static const ClassData                        _class_data_;
        const ::google::protobuf::Message::ClassData* GetClassData() const final;

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kFilenameFieldNumber = 1,
            kFilesizeFieldNumber = 2,
        };
        // string filename = 1;
        void               clear_filename();
        const std::string& filename() const;
        template <typename Arg_ = const std::string&, typename... Args_>
        void               set_filename(Arg_&& arg, Args_... args);
        std::string*       mutable_filename();
        PROTOBUF_NODISCARD std::string* release_filename();
        void                            set_allocated_filename(std::string* value);

    private:
        const std::string&                 _internal_filename() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
        std::string*                       _internal_mutable_filename();

    public:
        // int32 filesize = 2;
        void      clear_filesize();
        ::int32_t filesize() const;
        void      set_filesize(::int32_t value);

    private:
        ::int32_t _internal_filesize() const;
        void      _internal_set_filesize(::int32_t value);

    public:
        // @@protoc_insertion_point(class_scope:xmsg.XDirRes.XDir)
    private:
        class _Internal;

        friend class ::google::protobuf::internal::TcParser;
        static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 34, 2> _table_;
        friend class ::google::protobuf::MessageLite;
        friend class ::google::protobuf::Arena;
        template <typename T>
        friend class ::google::protobuf::Arena::InternalHelper;
        using InternalArenaConstructable_ = void;
        using DestructorSkippable_        = void;
        struct Impl_
        {
            inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena*                       arena);
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena* arena, const Impl_& from);
            ::google::protobuf::internal::ArenaStringPtr     filename_;
            ::int32_t                                        filesize_;
            mutable ::google::protobuf::internal::CachedSize _cached_size_;
            PROTOBUF_TSAN_DECLARE_MEMBER
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_XMsgCom_2eproto;
    }; // -------------------------------------------------------------------

    class XPLATFROM_EXPORT XDirReq final
        : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xmsg.XDirReq) */
    {
    public:
        inline XDirReq() : XDirReq(nullptr)
        {
        }
        ~XDirReq() override;
        template <typename = void>
        explicit PROTOBUF_CONSTEXPR XDirReq(::google::protobuf::internal::ConstantInitialized);

        inline XDirReq(const XDirReq& from) : XDirReq(nullptr, from)
        {
        }
        XDirReq(XDirReq&& from) noexcept : XDirReq()
        {
            *this = ::std::move(from);
        }

        inline XDirReq& operator=(const XDirReq& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline XDirReq& operator=(XDirReq&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(
                    ::google::protobuf::UnknownFieldSet::default_instance);
        }
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
        }

        static const ::google::protobuf::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::google::protobuf::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::google::protobuf::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const XDirReq& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const XDirReq* internal_default_instance()
        {
            return reinterpret_cast<const XDirReq*>(&_XDirReq_default_instance_);
        }
        static constexpr int kIndexInFileMessages = 3;

        friend void swap(XDirReq& a, XDirReq& b)
        {
            a.Swap(&b);
        }
        inline void Swap(XDirReq* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() != nullptr && GetArena() == other->GetArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() == other->GetArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::google::protobuf::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(XDirReq* other)
        {
            if (other == this)
                return;
            ABSL_DCHECK(GetArena() == other->GetArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        XDirReq* New(::google::protobuf::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<XDirReq>(arena);
        }
        using ::google::protobuf::Message::CopyFrom;
        void CopyFrom(const XDirReq& from);
        using ::google::protobuf::Message::MergeFrom;
        void MergeFrom(const XDirReq& from)
        {
            XDirReq::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool                                  IsInitialized() const final;

        ::size_t    ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
        ::uint8_t*  _InternalSerialize(::uint8_t*                                   target,
                                       ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
        int         GetCachedSize() const
        {
            return _impl_._cached_size_.Get();
        }

    private:
        ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
        void                                      SharedCtor(::google::protobuf::Arena* arena);
        void                                      SharedDtor();
        void                                      InternalSwap(XDirReq* other);

    private:
        friend class ::google::protobuf::internal::AnyMetadata;
        static ::absl::string_view FullMessageName()
        {
            return "xmsg.XDirReq";
        }

    protected:
        explicit XDirReq(::google::protobuf::Arena* arena);
        XDirReq(::google::protobuf::Arena* arena, const XDirReq& from);

    public:
        static const ClassData                        _class_data_;
        const ::google::protobuf::Message::ClassData* GetClassData() const final;

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPathFieldNumber = 1,
        };
        // string path = 1;
        void               clear_path();
        const std::string& path() const;
        template <typename Arg_ = const std::string&, typename... Args_>
        void               set_path(Arg_&& arg, Args_... args);
        std::string*       mutable_path();
        PROTOBUF_NODISCARD std::string* release_path();
        void                            set_allocated_path(std::string* value);

    private:
        const std::string&                 _internal_path() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
        std::string*                       _internal_mutable_path();

    public:
        // @@protoc_insertion_point(class_scope:xmsg.XDirReq)
    private:
        class _Internal;

        friend class ::google::protobuf::internal::TcParser;
        static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 25, 2> _table_;
        friend class ::google::protobuf::MessageLite;
        friend class ::google::protobuf::Arena;
        template <typename T>
        friend class ::google::protobuf::Arena::InternalHelper;
        using InternalArenaConstructable_ = void;
        using DestructorSkippable_        = void;
        struct Impl_
        {
            inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena*                       arena);
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena* arena, const Impl_& from);
            ::google::protobuf::internal::ArenaStringPtr     path_;
            mutable ::google::protobuf::internal::CachedSize _cached_size_;
            PROTOBUF_TSAN_DECLARE_MEMBER
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_XMsgCom_2eproto;
    }; // -------------------------------------------------------------------

    class XPLATFROM_EXPORT XDirRes final
        : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xmsg.XDirRes) */
    {
    public:
        inline XDirRes() : XDirRes(nullptr)
        {
        }
        ~XDirRes() override;
        template <typename = void>
        explicit PROTOBUF_CONSTEXPR XDirRes(::google::protobuf::internal::ConstantInitialized);

        inline XDirRes(const XDirRes& from) : XDirRes(nullptr, from)
        {
        }
        XDirRes(XDirRes&& from) noexcept : XDirRes()
        {
            *this = ::std::move(from);
        }

        inline XDirRes& operator=(const XDirRes& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline XDirRes& operator=(XDirRes&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(
                    ::google::protobuf::UnknownFieldSet::default_instance);
        }
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND
        {
            return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
        }

        static const ::google::protobuf::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::google::protobuf::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::google::protobuf::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const XDirRes& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const XDirRes* internal_default_instance()
        {
            return reinterpret_cast<const XDirRes*>(&_XDirRes_default_instance_);
        }
        static constexpr int kIndexInFileMessages = 5;

        friend void swap(XDirRes& a, XDirRes& b)
        {
            a.Swap(&b);
        }
        inline void Swap(XDirRes* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() != nullptr && GetArena() == other->GetArena())
            {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetArena() == other->GetArena())
            {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::google::protobuf::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(XDirRes* other)
        {
            if (other == this)
                return;
            ABSL_DCHECK(GetArena() == other->GetArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        XDirRes* New(::google::protobuf::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<XDirRes>(arena);
        }
        using ::google::protobuf::Message::CopyFrom;
        void CopyFrom(const XDirRes& from);
        using ::google::protobuf::Message::MergeFrom;
        void MergeFrom(const XDirRes& from)
        {
            XDirRes::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool                                  IsInitialized() const final;

        ::size_t    ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
        ::uint8_t*  _InternalSerialize(::uint8_t*                                   target,
                                       ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
        int         GetCachedSize() const
        {
            return _impl_._cached_size_.Get();
        }

    private:
        ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
        void                                      SharedCtor(::google::protobuf::Arena* arena);
        void                                      SharedDtor();
        void                                      InternalSwap(XDirRes* other);

    private:
        friend class ::google::protobuf::internal::AnyMetadata;
        static ::absl::string_view FullMessageName()
        {
            return "xmsg.XDirRes";
        }

    protected:
        explicit XDirRes(::google::protobuf::Arena* arena);
        XDirRes(::google::protobuf::Arena* arena, const XDirRes& from);

    public:
        static const ClassData                        _class_data_;
        const ::google::protobuf::Message::ClassData* GetClassData() const final;

        ::google::protobuf::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        using XDir = XDirRes_XDir;

        using XDirType                      = XDirRes_XDirType;
        static constexpr XDirType XDT_OK    = XDirRes_XDirType_XDT_OK;
        static constexpr XDirType XDT_ERROR = XDirRes_XDirType_XDT_ERROR;
        static constexpr XDirType XDT_NODIR = XDirRes_XDirType_XDT_NODIR;
        static inline bool        XDirType_IsValid(int value)
        {
            return XDirRes_XDirType_IsValid(value);
        }
        static constexpr XDirType XDirType_MIN       = XDirRes_XDirType_XDirType_MIN;
        static constexpr XDirType XDirType_MAX       = XDirRes_XDirType_XDirType_MAX;
        static constexpr int      XDirType_ARRAYSIZE = XDirRes_XDirType_XDirType_ARRAYSIZE;
        static inline const ::google::protobuf::EnumDescriptor* XDirType_descriptor()
        {
            return XDirRes_XDirType_descriptor();
        }
        template <typename T>
        static inline const std::string& XDirType_Name(T value)
        {
            return XDirRes_XDirType_Name(value);
        }
        static inline bool XDirType_Parse(absl::string_view name, XDirType* value)
        {
            return XDirRes_XDirType_Parse(name, value);
        }

        // accessors -------------------------------------------------------

        enum : int
        {
            kDirsFieldNumber    = 2,
            kResTypeFieldNumber = 1,
        };
        // repeated .xmsg.XDirRes.XDir dirs = 2;
        int dirs_size() const;

    private:
        int _internal_dirs_size() const;

    public:
        void                                                        clear_dirs();
        ::xmsg::XDirRes_XDir*                                       mutable_dirs(int index);
        ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>* mutable_dirs();

    private:
        const ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>& _internal_dirs() const;
        ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>*       _internal_mutable_dirs();

    public:
        const ::xmsg::XDirRes_XDir&                                       dirs(int index) const;
        ::xmsg::XDirRes_XDir*                                             add_dirs();
        const ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>& dirs() const;
        // .xmsg.XDirRes.XDirType resType = 1;
        void                     clear_restype();
        ::xmsg::XDirRes_XDirType restype() const;
        void                     set_restype(::xmsg::XDirRes_XDirType value);

    private:
        ::xmsg::XDirRes_XDirType _internal_restype() const;
        void                     _internal_set_restype(::xmsg::XDirRes_XDirType value);

    public:
        // @@protoc_insertion_point(class_scope:xmsg.XDirRes)
    private:
        class _Internal;

        friend class ::google::protobuf::internal::TcParser;
        static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
        friend class ::google::protobuf::MessageLite;
        friend class ::google::protobuf::Arena;
        template <typename T>
        friend class ::google::protobuf::Arena::InternalHelper;
        using InternalArenaConstructable_ = void;
        using DestructorSkippable_        = void;
        struct Impl_
        {
            inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena*                       arena);
            inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                                  ::google::protobuf::Arena* arena, const Impl_& from);
            ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir> dirs_;
            int                                                        restype_;
            mutable ::google::protobuf::internal::CachedSize           _cached_size_;
            PROTOBUF_TSAN_DECLARE_MEMBER
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_XMsgCom_2eproto;
    };

    // ===================================================================


    // ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
    // -------------------------------------------------------------------

    // XMsgHead

    // int32 msgSize = 1;
    inline void XMsgHead::clear_msgsize()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.msgsize_ = 0;
    }
    inline ::int32_t XMsgHead::msgsize() const
    {
        // @@protoc_insertion_point(field_get:xmsg.XMsgHead.msgSize)
        return _internal_msgsize();
    }
    inline void XMsgHead::set_msgsize(::int32_t value)
    {
        _internal_set_msgsize(value);
        // @@protoc_insertion_point(field_set:xmsg.XMsgHead.msgSize)
    }
    inline ::int32_t XMsgHead::_internal_msgsize() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.msgsize_;
    }
    inline void XMsgHead::_internal_set_msgsize(::int32_t value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.msgsize_ = value;
    }

    // .xmsg.MsgType msgType = 2;
    inline void XMsgHead::clear_msgtype()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.msgtype_ = 0;
    }
    inline ::xmsg::MsgType XMsgHead::msgtype() const
    {
        // @@protoc_insertion_point(field_get:xmsg.XMsgHead.msgType)
        return _internal_msgtype();
    }
    inline void XMsgHead::set_msgtype(::xmsg::MsgType value)
    {
        _internal_set_msgtype(value);
        // @@protoc_insertion_point(field_set:xmsg.XMsgHead.msgType)
    }
    inline ::xmsg::MsgType XMsgHead::_internal_msgtype() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return static_cast<::xmsg::MsgType>(_impl_.msgtype_);
    }
    inline void XMsgHead::_internal_set_msgtype(::xmsg::MsgType value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.msgtype_ = value;
    }

    // string token = 3;
    inline void XMsgHead::clear_token()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.token_.ClearToEmpty();
    }
    inline const std::string& XMsgHead::token() const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XMsgHead.token)
        return _internal_token();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void XMsgHead::set_token(Arg_&& arg, Args_... args)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
        // @@protoc_insertion_point(field_set:xmsg.XMsgHead.token)
    }
    inline std::string* XMsgHead::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        std::string* _s = _internal_mutable_token();
        // @@protoc_insertion_point(field_mutable:xmsg.XMsgHead.token)
        return _s;
    }
    inline const std::string& XMsgHead::_internal_token() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.token_.Get();
    }
    inline void XMsgHead::_internal_set_token(const std::string& value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.token_.Set(value, GetArena());
    }
    inline std::string* XMsgHead::_internal_mutable_token()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        return _impl_.token_.Mutable(GetArena());
    }
    inline std::string* XMsgHead::release_token()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        // @@protoc_insertion_point(field_release:xmsg.XMsgHead.token)
        return _impl_.token_.Release();
    }
    inline void XMsgHead::set_allocated_token(std::string* value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.token_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault())
        {
            _impl_.token_.Set("", GetArena());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:xmsg.XMsgHead.token)
    }

    // string serverName = 4;
    inline void XMsgHead::clear_servername()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.servername_.ClearToEmpty();
    }
    inline const std::string& XMsgHead::servername() const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XMsgHead.serverName)
        return _internal_servername();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void XMsgHead::set_servername(Arg_&& arg, Args_... args)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.servername_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
        // @@protoc_insertion_point(field_set:xmsg.XMsgHead.serverName)
    }
    inline std::string* XMsgHead::mutable_servername() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        std::string* _s = _internal_mutable_servername();
        // @@protoc_insertion_point(field_mutable:xmsg.XMsgHead.serverName)
        return _s;
    }
    inline const std::string& XMsgHead::_internal_servername() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.servername_.Get();
    }
    inline void XMsgHead::_internal_set_servername(const std::string& value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.servername_.Set(value, GetArena());
    }
    inline std::string* XMsgHead::_internal_mutable_servername()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        return _impl_.servername_.Mutable(GetArena());
    }
    inline std::string* XMsgHead::release_servername()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        // @@protoc_insertion_point(field_release:xmsg.XMsgHead.serverName)
        return _impl_.servername_.Release();
    }
    inline void XMsgHead::set_allocated_servername(std::string* value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.servername_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.servername_.IsDefault())
        {
            _impl_.servername_.Set("", GetArena());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:xmsg.XMsgHead.serverName)
    }

    // -------------------------------------------------------------------

    // XLoginReq

    // string username = 1;
    inline void XLoginReq::clear_username()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.username_.ClearToEmpty();
    }
    inline const std::string& XLoginReq::username() const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XLoginReq.username)
        return _internal_username();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void XLoginReq::set_username(Arg_&& arg, Args_... args)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
        // @@protoc_insertion_point(field_set:xmsg.XLoginReq.username)
    }
    inline std::string* XLoginReq::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        std::string* _s = _internal_mutable_username();
        // @@protoc_insertion_point(field_mutable:xmsg.XLoginReq.username)
        return _s;
    }
    inline const std::string& XLoginReq::_internal_username() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.username_.Get();
    }
    inline void XLoginReq::_internal_set_username(const std::string& value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.username_.Set(value, GetArena());
    }
    inline std::string* XLoginReq::_internal_mutable_username()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        return _impl_.username_.Mutable(GetArena());
    }
    inline std::string* XLoginReq::release_username()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        // @@protoc_insertion_point(field_release:xmsg.XLoginReq.username)
        return _impl_.username_.Release();
    }
    inline void XLoginReq::set_allocated_username(std::string* value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.username_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault())
        {
            _impl_.username_.Set("", GetArena());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginReq.username)
    }

    // string password = 2;
    inline void XLoginReq::clear_password()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.password_.ClearToEmpty();
    }
    inline const std::string& XLoginReq::password() const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XLoginReq.password)
        return _internal_password();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void XLoginReq::set_password(Arg_&& arg, Args_... args)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
        // @@protoc_insertion_point(field_set:xmsg.XLoginReq.password)
    }
    inline std::string* XLoginReq::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        std::string* _s = _internal_mutable_password();
        // @@protoc_insertion_point(field_mutable:xmsg.XLoginReq.password)
        return _s;
    }
    inline const std::string& XLoginReq::_internal_password() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.password_.Get();
    }
    inline void XLoginReq::_internal_set_password(const std::string& value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.password_.Set(value, GetArena());
    }
    inline std::string* XLoginReq::_internal_mutable_password()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        return _impl_.password_.Mutable(GetArena());
    }
    inline std::string* XLoginReq::release_password()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        // @@protoc_insertion_point(field_release:xmsg.XLoginReq.password)
        return _impl_.password_.Release();
    }
    inline void XLoginReq::set_allocated_password(std::string* value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.password_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault())
        {
            _impl_.password_.Set("", GetArena());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginReq.password)
    }

    // -------------------------------------------------------------------

    // XLoginRes

    // .xmsg.XLoginRes.XLoginResType resType = 1;
    inline void XLoginRes::clear_restype()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.restype_ = 0;
    }
    inline ::xmsg::XLoginRes_XLoginResType XLoginRes::restype() const
    {
        // @@protoc_insertion_point(field_get:xmsg.XLoginRes.resType)
        return _internal_restype();
    }
    inline void XLoginRes::set_restype(::xmsg::XLoginRes_XLoginResType value)
    {
        _internal_set_restype(value);
        // @@protoc_insertion_point(field_set:xmsg.XLoginRes.resType)
    }
    inline ::xmsg::XLoginRes_XLoginResType XLoginRes::_internal_restype() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return static_cast<::xmsg::XLoginRes_XLoginResType>(_impl_.restype_);
    }
    inline void XLoginRes::_internal_set_restype(::xmsg::XLoginRes_XLoginResType value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.restype_ = value;
    }

    // string token = 2;
    inline void XLoginRes::clear_token()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.token_.ClearToEmpty();
    }
    inline const std::string& XLoginRes::token() const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XLoginRes.token)
        return _internal_token();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void XLoginRes::set_token(Arg_&& arg, Args_... args)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
        // @@protoc_insertion_point(field_set:xmsg.XLoginRes.token)
    }
    inline std::string* XLoginRes::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        std::string* _s = _internal_mutable_token();
        // @@protoc_insertion_point(field_mutable:xmsg.XLoginRes.token)
        return _s;
    }
    inline const std::string& XLoginRes::_internal_token() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.token_.Get();
    }
    inline void XLoginRes::_internal_set_token(const std::string& value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.token_.Set(value, GetArena());
    }
    inline std::string* XLoginRes::_internal_mutable_token()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        return _impl_.token_.Mutable(GetArena());
    }
    inline std::string* XLoginRes::release_token()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        // @@protoc_insertion_point(field_release:xmsg.XLoginRes.token)
        return _impl_.token_.Release();
    }
    inline void XLoginRes::set_allocated_token(std::string* value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.token_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault())
        {
            _impl_.token_.Set("", GetArena());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginRes.token)
    }

    // -------------------------------------------------------------------

    // XDirReq

    // string path = 1;
    inline void XDirReq::clear_path()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.path_.ClearToEmpty();
    }
    inline const std::string& XDirReq::path() const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XDirReq.path)
        return _internal_path();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void XDirReq::set_path(Arg_&& arg, Args_... args)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
        // @@protoc_insertion_point(field_set:xmsg.XDirReq.path)
    }
    inline std::string* XDirReq::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        std::string* _s = _internal_mutable_path();
        // @@protoc_insertion_point(field_mutable:xmsg.XDirReq.path)
        return _s;
    }
    inline const std::string& XDirReq::_internal_path() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.path_.Get();
    }
    inline void XDirReq::_internal_set_path(const std::string& value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.path_.Set(value, GetArena());
    }
    inline std::string* XDirReq::_internal_mutable_path()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        return _impl_.path_.Mutable(GetArena());
    }
    inline std::string* XDirReq::release_path()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        // @@protoc_insertion_point(field_release:xmsg.XDirReq.path)
        return _impl_.path_.Release();
    }
    inline void XDirReq::set_allocated_path(std::string* value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.path_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault())
        {
            _impl_.path_.Set("", GetArena());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:xmsg.XDirReq.path)
    }

    // -------------------------------------------------------------------

    // XDirRes_XDir

    // string filename = 1;
    inline void XDirRes_XDir::clear_filename()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.filename_.ClearToEmpty();
    }
    inline const std::string& XDirRes_XDir::filename() const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XDirRes.XDir.filename)
        return _internal_filename();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void XDirRes_XDir::set_filename(Arg_&& arg, Args_... args)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
        // @@protoc_insertion_point(field_set:xmsg.XDirRes.XDir.filename)
    }
    inline std::string* XDirRes_XDir::mutable_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        std::string* _s = _internal_mutable_filename();
        // @@protoc_insertion_point(field_mutable:xmsg.XDirRes.XDir.filename)
        return _s;
    }
    inline const std::string& XDirRes_XDir::_internal_filename() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.filename_.Get();
    }
    inline void XDirRes_XDir::_internal_set_filename(const std::string& value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.filename_.Set(value, GetArena());
    }
    inline std::string* XDirRes_XDir::_internal_mutable_filename()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        return _impl_.filename_.Mutable(GetArena());
    }
    inline std::string* XDirRes_XDir::release_filename()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        // @@protoc_insertion_point(field_release:xmsg.XDirRes.XDir.filename)
        return _impl_.filename_.Release();
    }
    inline void XDirRes_XDir::set_allocated_filename(std::string* value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.filename_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filename_.IsDefault())
        {
            _impl_.filename_.Set("", GetArena());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:xmsg.XDirRes.XDir.filename)
    }

    // int32 filesize = 2;
    inline void XDirRes_XDir::clear_filesize()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.filesize_ = 0;
    }
    inline ::int32_t XDirRes_XDir::filesize() const
    {
        // @@protoc_insertion_point(field_get:xmsg.XDirRes.XDir.filesize)
        return _internal_filesize();
    }
    inline void XDirRes_XDir::set_filesize(::int32_t value)
    {
        _internal_set_filesize(value);
        // @@protoc_insertion_point(field_set:xmsg.XDirRes.XDir.filesize)
    }
    inline ::int32_t XDirRes_XDir::_internal_filesize() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.filesize_;
    }
    inline void XDirRes_XDir::_internal_set_filesize(::int32_t value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.filesize_ = value;
    }

    // -------------------------------------------------------------------

    // XDirRes

    // .xmsg.XDirRes.XDirType resType = 1;
    inline void XDirRes::clear_restype()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.restype_ = 0;
    }
    inline ::xmsg::XDirRes_XDirType XDirRes::restype() const
    {
        // @@protoc_insertion_point(field_get:xmsg.XDirRes.resType)
        return _internal_restype();
    }
    inline void XDirRes::set_restype(::xmsg::XDirRes_XDirType value)
    {
        _internal_set_restype(value);
        // @@protoc_insertion_point(field_set:xmsg.XDirRes.resType)
    }
    inline ::xmsg::XDirRes_XDirType XDirRes::_internal_restype() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return static_cast<::xmsg::XDirRes_XDirType>(_impl_.restype_);
    }
    inline void XDirRes::_internal_set_restype(::xmsg::XDirRes_XDirType value)
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ;
        _impl_.restype_ = value;
    }

    // repeated .xmsg.XDirRes.XDir dirs = 2;
    inline int XDirRes::_internal_dirs_size() const
    {
        return _internal_dirs().size();
    }
    inline int XDirRes::dirs_size() const
    {
        return _internal_dirs_size();
    }
    inline void XDirRes::clear_dirs()
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        _impl_.dirs_.Clear();
    }
    inline ::xmsg::XDirRes_XDir* XDirRes::mutable_dirs(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_mutable:xmsg.XDirRes.dirs)
        return _internal_mutable_dirs()->Mutable(index);
    }
    inline ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>* XDirRes::mutable_dirs()
            ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_mutable_list:xmsg.XDirRes.dirs)
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        return _internal_mutable_dirs();
    }
    inline const ::xmsg::XDirRes_XDir& XDirRes::dirs(int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_get:xmsg.XDirRes.dirs)
        return _internal_dirs().Get(index);
    }
    inline ::xmsg::XDirRes_XDir* XDirRes::add_dirs() ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
        ::xmsg::XDirRes_XDir* _add = _internal_mutable_dirs()->Add();
        // @@protoc_insertion_point(field_add:xmsg.XDirRes.dirs)
        return _add;
    }
    inline const ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>& XDirRes::dirs() const
            ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        // @@protoc_insertion_point(field_list:xmsg.XDirRes.dirs)
        return _internal_dirs();
    }
    inline const ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>& XDirRes::_internal_dirs() const
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return _impl_.dirs_;
    }
    inline ::google::protobuf::RepeatedPtrField<::xmsg::XDirRes_XDir>* XDirRes::_internal_mutable_dirs()
    {
        PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
        return &_impl_.dirs_;
    }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

    // @@protoc_insertion_point(namespace_scope)
} // namespace xmsg


namespace google
{
    namespace protobuf
    {

        template <>
        struct is_proto_enum<::xmsg::XLoginRes_XLoginResType> : std::true_type
        {
        };
        template <>
        inline const EnumDescriptor* GetEnumDescriptor<::xmsg::XLoginRes_XLoginResType>()
        {
            return ::xmsg::XLoginRes_XLoginResType_descriptor();
        }
        template <>
        struct is_proto_enum<::xmsg::XDirRes_XDirType> : std::true_type
        {
        };
        template <>
        inline const EnumDescriptor* GetEnumDescriptor<::xmsg::XDirRes_XDirType>()
        {
            return ::xmsg::XDirRes_XDirType_descriptor();
        }

    } // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif // GOOGLE_PROTOBUF_INCLUDED_XMsgCom_2eproto_2epb_2eh
